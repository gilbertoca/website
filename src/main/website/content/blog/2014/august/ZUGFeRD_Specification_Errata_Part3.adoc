= Errors in the ZUGFeRD Specification Part 3
Vadim Bauer
2014-08-6
:jbake-type: post
:jbake-status: draft
:jbake-tags: Specification errors	
:idprefix:
:linkattrs:
:icons: font
:1: <<Errors in the ZUGFeRD Specification Part 1>>


Let us take another look at chapter ""6.5.3 Datumsformate"". 
""
Bedingt durch die verwendete Referenzbibliothek von UN/CEFACT existieren in ZUGFeRD zwei grundle-
gende Datumsformate. In den meisten Fällen kann ein Datum als formatierter String mit Formatangabe
übertragen werden. Somit sind auch die Angaben zum Beispiel von Leistungszeiträumen möglich. Als Da-
tumsformate sind in ZUGFeRD nur das Kalenderdatum – JJJJMMTT (Codewert 102), der Kalendermonat –
JJJJMM (Codewert 610) und die Kalenderwoche – JJJJWW (Codewert 616), z.B. bei Lieferzeitraum, zugelas-
sen. Insbesondere bei Dokumentenreferenzen wird das Belegdatum als XML DateTime-Datentyp angege-
ben werden. Das Format lautet dann *jjjj-mm-ttThh:mm:ss*, also beispielsweise +2014-06-25T00:00:00+.
""

In {1} I mentioned already the date time discrepancy in specification vs. model.

[source,xml,indent=0]
----
<xs:simpleType name="DateMandatoryDateTimeType">
	<xs:union memberTypes="xs:dateTime xs:date"/>
</xs:simpleType>
----
4.5.2. Datatypes

Point in time: xs:dateTime
The xs:dateTime datatype defines a "specific instant of time." This is a subset of what ISO 8601 calls a "moment of time." Its lexical value follows the format "CCYY-MM-DDThh:mm:ss," in which all the fields must be present and may optionally be preceded by a sign and leading figures, if needed, and followed by fractional digits for the seconds and a time zone. The time zone may be specified using the letter "Z," which identifies UTC, or by the difference of time with UTC.
TIP: The value space of xs:dateTime is considered to be the moment of time itself. The time zone that defines the value (when there is one) is considered meaningless, which is a problem for some applications that complain that even though 2002-01-18T12:00:00+00:00 and 2002-01-18T11:00:00-01:00 refer to the same "moment of time," they carry different time zone information, which should make its way into the value space.
Valid values for xs:dateTime include:

2001-10-26T21:32:52

2001-10-26T21:32:52+02:00

2001-10-26T19:32:52Z

2001-10-26T19:32:52+00:00

-2001-10-26T21:32:52

2001-10-26T21:32:52.12679

The following values are invalid:

2001-10-26 (all the parts must be specified)

2001-10-26T21:32 (all the parts must be specified)

2001-10-26T25:32:52+02:00 (the hours part (25) is out of range)

01-10-26T21:32 (all the parts must be specified)

In the valid examples given above, three of them have identical value spaces:

2001-10-26T21:32:52+02:00

2001-10-26T19:32:52Z

2001-10-26T19:32:52+00:00

The first one (2001-10-26T21:32:52), which doesn't include a time zone specification, is considered to have an indeterminate value between 2001-10-26T21:32:52-14:00 and 2001-10-26T21:32:52+14:00. With the usage of summer saving time, this range is subject to national regulations and may change. The range was between -13:00 and +12:00 when the Recommendation was published, but the Working Group has kept a margin to accommodate possible changes in the regulations.

Despite the indeterminacy of the time zone when none is specified, the W3C XML Schema Recommendation considers that the values of datetimes without time zones implicitly refer to the same undetermined time zone and can be compared between them. While this is fine for "local" applications that operate in a single time zone, this is a source of potential confusion and errors for world-wide applications or even for applications that calculate a duration between moments belonging to different time saving seasons within a single time zone.

Periods of time: xs:date, xs:gYearMonth and xs:gYear.
The lexical space of xs:date datatype is identical to the date part of xs:dateTime. Like xs:dateTime, it includes a time zone that should always be specified to be able to compare two dates without ambiguity. As defined per W3C XML Schema, a date is a period one day in its time zone, "independent of how many hours this day has." The consequence of this definition is that two dates defined in a different time zone cannot be equal except if they designate the same interval (2001-10-26+12:00 and 2001-10-25-12:00, for instance). Another consequence is that, like with xs:dateTime, the order relation between a date with a time zone and a date without a time zone is partial.
Valid values for xs:date include:

2001-10-26

2001-10-26+02:00

2001-10-26Z

2001-10-26+00:00

-2001-10-26

-20000-04-01

The following values are invalid:

2001-10 (all the parts must be specified)

2001-10-32 (the days part (32) is out of range)

2001-13-26+02:00 (the month part (13) is out of range)

01-10-26 (the century part is missing)

xs:date represents a day identified by a Gregorian calendar date (and could have been called "gYearMonthDay"). xs:gYearMonth ("g" for Gregorian) is a Gregorian calendar month and xs:gYear is a Gregorian calendar year. These three datatypes are fixed periods of time and optional time zones may be specified for each of them. The only differences between them really are their length (1 day, 1 month, and 1 year) and their format (i.e., their lexical spaces).























Last week I posted about <<{3},Errors in the ZUGFeRD Specification>>. 
A reply to my questions came very quickly from FeRD({4}) stating 
that the documentation and the resulting XSD Schema are correct.

The explanation for the differences is based on the fact the ZUGFeRD XSD schema is designed following the 
{1}[Venetian blind] 
XML Schema design pattern. 

""
Die CCL ist nach dem Desingprinzip Venetian Blind aufgebaut (Kapitel 6.1, sowie technische Dokumentation Kapitel 4.3), 
wodurch sich XSD und Spezifikation formal unterscheiden. 
Die Lösung dafür bietet die ebenfalls veröffentlichte Schematron-Datei (Kapitel 10.6), die genau diese Designlücke schließt. 
Eine Validierung erfolgt bei ZUGFeRD also immer in der Kombination aus XSD-Validierung und Schematron-Validierung. 
Die in der gedruckten Spezifikation enthaltenen Informationen haben somit also volle Richtigkeit.
""

After reading about the XML Schema design and the ZUGFeRD specification and the XSD file I came to the conclusion that:

- There is no explanation why the resulting cardinalities need to be  +1..N+ instead of +1..1+ in the XSD Schema file.
- {2}[Designing forward and backward compatible XML Schemas] is very difficult.
- The XSD Schema alone is pretty useless for ZUGFeRD invoice validation.

Finally we have to take into account the four different documents provided.

- ZUGFeRD Model (Chapter "3 Das semantische ZUGFeRD-Datenmodell" in "Das ZUGFeRD-Format_1p0_technische_Dokumentation.pdf")
- ZUGFeRD Schema (Chapter "4 Das ZUGFeRD-Schema" in "Das ZUGFeRD-Format_1p0_technische_Dokumentation.pdf")
- ZUGFeRD XSD File (ZUGFeRD_1p0.xsd)
- ZUGFeRD Schematron (ZUGFeRD_1p0.scmt)


Only all four together provide us with a valid ZUGFeRD compliant invoice. 
Validating your XML Invoice file  against only the XSD Schema does not guarantee a ZUGFeRD compliant Invoice. 
Also a successful validation of an XML file against Schematron is not a guarantee.

CEFEG shutdown their validation service, because it is based on XSD 
Schema validation and Schematron which cannot guarantee a correct invoice 
at the current state of development at least.

.Error Message on the eInvoice Validation Portal din-zugferd-validation.org.
image::img/blog/july/din-zugferd-validation.org_error_message.png["Error Message on din-zugferd-validation.org telling that they can't validate correctly ZUGFeRD Invoices"]


== Incorrect XML Examples

This week I am going to publish {5}[corrected XML Invoice Example File]. 
While working on the next release of the Konik library and adding 
validation features to the library, it was noticed that some of the existent ZUGFeRD 
examples were marked as incorrect.

Let's take a look at file +Beispielrechnung_1p0_COMFORT.xml+ which is part of 
the ZUGFeRD specification package as an example to explain what is incorrect 
regarding the ZUGFeRD model.

[source,xml,indent=0]
----
 <ram:SpecifiedTradeAllowanceCharge>
    <ram:ChargeIndicator>
       <udt:Indicator>false</udt:Indicator>
    </ram:ChargeIndicator>
    <ram:BasisAmount currencyID="EUR">10.00</ram:BasisAmount>
    <ram:ActualAmount>1.00</ram:ActualAmount> # <1>
	<!-- ... -->
 </ram:SpecifiedTradeAllowanceCharge>
 <!-- ... -->
 <ram:SpecifiedLogisticsServiceCharge>
    <ram:Description>Versandkosten</ram:Description>
    <ram:AppliedAmount>5.80</ram:AppliedAmount> # <2>
     <!-- ... -->
 </ram:SpecifiedLogisticsServiceCharge>
----
<1> The +ActualAmount+ contains only the value and no attribute with the currency like in +BasisAmount+ one line above.
<2> +AppliedAmount+ is also defined as +udt:AmountType+ and hence should also contain a currency attribute.

The ZUGFeRD model stated that all +udt:AmountType+ require an Currency Code. 
.+udt:AmountType+ requiring a currency code in +ApplicableTradeTax+
image::img/blog/july/AmountType_Example.png["udt:AmountType requiring a currency code"]


The Model and the Schema declare +udt:AmountType+ as required but not the XSD File.

=== Solution

The first and probably best solution is to use a library such as Konik which will assist 
you in creating a valid and ZUGFeRD compliant invoice. Konik will also make the XSD 
Schema Validation and Schematron optional.
The second solution would be to modify the XSD Schema file 
according to the model and ZUGFeRD schema definition to get at least an 
error when validating the xml against the XSD Schema.

[source,xml,indent=0]
----
<xs:schema xmlns:udt="urn:un:unece:uncefact:data:standard:UnqualifiedDataType:15" xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="urn:un:unece:uncefact:data:standard:UnqualifiedDataType:15" elementFormDefault="qualified" version="15.0">
	<xs:complexType name="AmountType">
		<xs:simpleContent>
			<xs:extension base="xs:decimal">
				<xs:attribute name="currencyID" type="udt:AmountTypeCurrencyIDContentType" use="required"/> # <1>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
----
<1> Add +use="required"+ to mark the attribute as required so the validation of the XML Files 
against the XSD Schema will fail.

Maybe because of the Venetian blind schema design requirements or the automatic 
generation of the XSD Schema File from the ZUGFeRD Schema definition, this was not done.




